<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gamer Cat</title>
    <link>https://samsonchen1989.github.io/</link>
    <description>Recent content on Gamer Cat</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 09 Oct 2016 23:05:06 +0800</lastBuildDate>
    <atom:link href="https://samsonchen1989.github.io/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>程序生成地下城(2) #整理 #翻译 #Unity</title>
      <link>https://samsonchen1989.github.io/post/proc2/</link>
      <pubDate>Sun, 09 Oct 2016 23:05:06 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/proc2/</guid>
      <description>

&lt;p&gt;在&lt;a href=&#34;https://samsonchen1989.github.io/post/proc1/&#34;&gt;上一篇教程&lt;/a&gt;的最后，我们可以得到类似下面一张地下城图：
&lt;img src=&#34;https://samsonchen1989.github.io/img/proc2_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;存在两个问题，一个是存在一些零星的独立区域，一个是有些大区域互不相连。要解决这两个问题，要先引入&lt;strong&gt;区域Region&lt;/strong&gt;的概念，把每个独立的区域（包括墙和空白区域）看做一个Region，然后针对这些Region进行处理。&lt;/p&gt;

&lt;h4 id=&#34;用flood-fill方法获取属于同一region的格子grid&#34;&gt;用Flood Fill方法获取属于同一Region的格子Grid&lt;/h4&gt;

&lt;p&gt;先建立一个&lt;code&gt;struct Coord&lt;/code&gt; 来抽象格子，里面只有两个属性，X坐标和Y坐标。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;struct Coord {
    public int tileX;
    public int tileY;

    public Coord(int x, int y) {
        tileX = x;
        tileY = y;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用Flood Fill（可参考&lt;a href=&#34;https://en.wikipedia.org/wiki/Flood_fill&#34;&gt;Wiki&lt;/a&gt;）方式来寻找同一Region内的Coord，简单来说，就是递归查找格子的上下左右四个相邻格子，直到所有相邻格子的类型（0表示空地，1表示墙）不同。
&lt;img src=&#34;https://samsonchen1989.github.io/img/proc2_7.gif&#34; alt=&#34;4方向的Flood Fill动态示意&#34; /&gt;&lt;/p&gt;

&lt;p&gt;考虑到递归方法虽然容易理解，但会大量占用function stack，在对程序效率要求比较高时还是尽量采取非递归的函数实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;List&amp;lt;Coord&amp;gt; GetRegionTiles(int startX, int startY) {
    // List to store region tile
    List&amp;lt;Coord&amp;gt; tiles = new List&amp;lt;Coord&amp;gt;();
    // Checked(1) or not(0)
    int[,] mapTag = new int[width, height];
    // Start tile filled or empty
    int tileType = map[startX, startY];

    Queue&amp;lt;Coord&amp;gt; queue = new Queue&amp;lt;Coord&amp;gt;();
    queue.Enqueue(new Coord(startX, startY));
    mapTag[startX, startY] = 1;

    while (queue.Count &amp;gt; 0) {
        Coord tile = queue.Dequeue();
        tiles.Add(tile);
        // Check tile&#39;s surrounding tiles
        for (int x = tile.tileX - 1; x &amp;lt;= tile.tileX + 1; x++) {
            for (int y = tile.tileY - 1; y &amp;lt;= tile.tileY + 1; y++) {
                // (x == tile.tileX || y == tile.tileY) just to check four neighbour tiles: up, left, right, down
                if (IsInMapRange(x, y) &amp;amp;&amp;amp; (x == tile.tileX || y == tile.tileY)) {
                    if (mapTag[x, y] == 0 &amp;amp;&amp;amp; tileType == map[x, y]) {
                        queue.Enqueue(new Coord(x, y));
                        mapTag[x, y] = 1;
                    }
                }
            }
        }
    }

    return tiles;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从一个起始点&lt;code&gt;(startX, startY)&lt;/code&gt;开始，用一个&lt;code&gt;queue&lt;/code&gt;&lt;strong&gt;(First In First Out)&lt;/strong&gt;储存属于同一type的周边格子，然后每次加入到返回结果列表tiles时再次检查周边格子，实现Flood Fill的递归。&lt;code&gt;mapTag&lt;/code&gt;数组用来防止重复检查。&lt;/p&gt;

&lt;p&gt;有了这个方法，我们就可以获取到各个Region，以及各个Region所包含的所有&lt;code&gt;Coord&lt;/code&gt;坐标信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;List&amp;lt;List&amp;lt;Coord&amp;gt;&amp;gt; GetRegions(int tileType) {
    List&amp;lt;List&amp;lt;Coord&amp;gt;&amp;gt; regions = new List&amp;lt;List&amp;lt;Coord&amp;gt;&amp;gt;();
    // 0 unchecked, 1 checked
    int[,] mapTag = new int[width, height];

    for (int x = 0; x &amp;lt; width; x++) {
        for (int y = 0; y &amp;lt; height; y++) {
            if (mapTag[x, y] == 0 &amp;amp;&amp;amp; map[x, y] == tileType) {
                List&amp;lt;Coord&amp;gt; region = GetRegionTiles(x, y);
                regions.Add(region);
                // Set all tiles to checked
                foreach (Coord tile in region) {
                    mapTag[tile.tileX, tile.tileY] = 1;
                }
            }
        }
    }

    return regions;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入的&lt;code&gt;tileType&lt;/code&gt;表示我们要查找的Region属性，如果传入1，则返回所有表示墙的Region列表&lt;code&gt;wallRegions&lt;/code&gt;，如果传入0，则返回所有空白区域列表，即所有的房间&lt;code&gt;roomRegions&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;去除小型region&#34;&gt;去除小型Region&lt;/h4&gt;

&lt;p&gt;设定一个&lt;code&gt;thresholdSize&lt;/code&gt;值，在获取所有&lt;code&gt;wallRegions&lt;/code&gt;和&lt;code&gt;roomRegions&lt;/code&gt;时，如果Region包含的格子数量小于&lt;code&gt;thresholdSize&lt;/code&gt;，则消除或填充该Region。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;List&amp;lt;List&amp;lt;Coord&amp;gt;&amp;gt; wallRegions = GetRegions(1);
int wallThresholdSize = 50;
foreach (List&amp;lt;Coord&amp;gt; wallRegion in wallRegions) {
    if (wallRegion.Count &amp;lt; wallThresholdSize) {
        foreach (Coord tile in wallRegion) {
            // Set all tiny wall region to empty tile
            map[tile.tileX, tile.tileY] = 0;
        }
    }
}

// Get empty rooms
List&amp;lt;List&amp;lt;Coord&amp;gt;&amp;gt; roomRegions = GetRegions(0);
int roomThresholdSize = 50;
foreach (List&amp;lt;Coord&amp;gt; roomRegion in roomRegions) {
    if (roomRegion.Count &amp;lt; roomThresholdSize) {
        foreach (Coord tile in roomRegion) {
            // Set all tiny room to filled tile
            map[tile.tileX, tile.tileY] = 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入这步处理，可以看到上面的地下城图又规整了许多：
&lt;img src=&#34;https://samsonchen1989.github.io/img/proc2_2.png&#34; alt=&#34;去除过小region后的地下城&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;连接房间roomregions&#34;&gt;连接房间roomRegions&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/proc2_3.png&#34; alt=&#34;Flood Fill&#34; /&gt;
&lt;img src=&#34;https://samsonchen1989.github.io/img/proc2_4.png&#34; alt=&#34;获得的各个Room列表roomRegions&#34; /&gt;&lt;/p&gt;

&lt;p&gt;既然获取到了所有房间的列表，接下来就是要遵循一定规则把所有房间连接起来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;所有房间与距离最接近的房间相连。&lt;/li&gt;
&lt;li&gt;确保所有房间互相连接，不会出现独立的房间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新建一个Room类，用来抽象房间，里面属性包含：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Coord&amp;gt; tiles&lt;/code&gt;，Room包含的所有点的坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Coord&amp;gt; edgeTiles&lt;/code&gt;，所有Room内边缘的点，即left，up，right，down四周有一个点是墙&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Room&amp;gt; connectedRooms&lt;/code&gt;，所有已连接的Room索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在构造函数中，计算出&lt;code&gt;edgeTiles&lt;/code&gt;，后面会用它来计算两个房间之间的最短连接路线。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public Room(List&amp;lt;Coord&amp;gt; roomTiles, int[,] map) {
    tiles = roomTiles;
    roomSize = tiles.Count;
    connectedRooms = new List&amp;lt;Room&amp;gt;();

    edgeTiles = new List&amp;lt;Coord&amp;gt;();
    foreach (Coord tile in tiles) {
        for (int x = tile.tileX-1; x &amp;lt;= tile.tileX+1; x++) {
            for (int y = tile.tileY-1; y &amp;lt;= tile.tileY+1; y++) {
                if (x == tile.tileX || y == tile.tileY) {
                    if (map[x,y] == 1) {
                        edgeTiles.Add(tile);
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外加入两个方法&lt;code&gt;ConnectRooms(Room a, Room b)&lt;/code&gt;和&lt;code&gt;IsConnected(Room other)&lt;/code&gt;来把已连接的Room添加到connectedRooms里和检测是否已连接到当前Room。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static void ConnectRooms(Room roomA, Room roomB) {
    roomA.connectedRooms.Add (roomB);
    roomB.connectedRooms.Add (roomA);
}

public bool IsConnected(Room otherRoom) {
    return connectedRooms.Contains(otherRoom);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面开始构造一个函数&lt;code&gt;ConnectClosestRooms(List&amp;lt;Room&amp;gt; allRooms)&lt;/code&gt;，Input是所有Room的List，然后用Unity里面&lt;code&gt;Debug.DrawLine&lt;/code&gt;方法先画出Room间的连接路径。思路是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历allRooms，获取roomA，其他所有Room集合称为roomBList。&lt;/li&gt;
&lt;li&gt;遍历roomBList，获取roomB。&lt;/li&gt;
&lt;li&gt;遍历roomA的边缘edgeTiles和roomB的边缘edgeTiles，算出最小距离&lt;code&gt;distanceBetweenRooms&lt;/code&gt;和两边的边缘点&lt;code&gt;tileA&lt;/code&gt;和&lt;code&gt;tileB&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;重复步骤2的遍历，直到找到最小的&lt;code&gt;distanceBetweenRooms&lt;/code&gt;和对应的&lt;code&gt;tileA&lt;/code&gt;，&lt;code&gt;tileB&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;连接tileA和tileB。&lt;/li&gt;
&lt;li&gt;重复步骤1。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;程序实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void ConnectClosestRooms(List&amp;lt;Room&amp;gt; allRooms) {
    int bestDistance = 0;
    Coord bestTileA = new Coord();
    Coord bestTileB = new Coord();
    Room bestRoomA = new Room();
    Room bestRoomB = new Room();
    bool possibleConnectionFound = false;

    foreach (Room roomA in allRooms) {
        possibleConnectionFound = false;

        foreach (Room roomB in allRooms) {
            if (roomA == roomB) {
                continue;
            }

            if (roomA.isConnected(roomB)) {
                possibleConnectionFound = false;
                break;
            }

            for (int tileIndexA = 0; tileIndexA &amp;lt; roomA.edgeTiles.Count; tileIndexA++) {
                for (int tileIndexB = 0; tileIndexB &amp;lt; roomB.edgeTiles.Count; tileIndexB++) {
                    Coord tileA = roomA.edgeTiles[tileIndexA];
                    Coord tileB = roomB.edgeTiles[tileIndexB];
                    int distanceBetweenRooms = (int)(Mathf.Pow(tileA.tileX - tileB.tileX, 2) + Mathf.Pow(tileA.tileY - tileB.tileY, 2));
                    if (distanceBetweenRooms &amp;lt; bestDistance || !possibleConnectionFound) {
                        bestDistance = distanceBetweenRooms;
                        possibleConnectionFound = true;
                        bestTileA = tileA;
                        bestTileB = tileB;
                        bestRoomA = roomA;
                        bestRoomB = roomB;
                    }
                }
            }
        }

        if (possibleConnectionFound) {
            CreatePassage(bestRoomA, bestRoomB, bestTileA, bestTileB);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入运行后在Scene窗口可以看到如下图的路径被创建：
&lt;img src=&#34;https://samsonchen1989.github.io/img/proc2_5.png&#34; alt=&#34;并没有完全连接的Room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;等等，似乎有哪里不对！为什么少了一条路径，难道是前面的&lt;code&gt;ConnectClosestRooms&lt;/code&gt;方法实现思路有问题？&lt;/p&gt;

&lt;p&gt;的确，再想想的话，会发现前面的思路可以满足&lt;strong&gt;条件1： 所有房间与距离最接近的房间相连&lt;/strong&gt;，但无法确保满足&lt;strong&gt;条件2：不会出现独立的房间。&lt;/strong&gt;在上面实现的基础上，我们需要引入一个新概念：&lt;strong&gt;主房间MainRoom&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;主房间就是所有房间中面积最大的房间，在&lt;code&gt;ConnectClosestRooms&lt;/code&gt;处理过后，按照下面流程再做一次处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在建立roomRegions时，选出面积最大的房间mainRoom。&lt;/li&gt;
&lt;li&gt;设定所有与主房间连接的房间为&lt;code&gt;connectedRooms&lt;/code&gt;，所有未和主房间连接的房间为&lt;code&gt;otherRooms&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历&lt;code&gt;otherRooms&lt;/code&gt;和&lt;code&gt;connectedRooms&lt;/code&gt;的边缘tiles，找出一条最短连接路线和两个顶点&lt;code&gt;tileA&lt;/code&gt;和&lt;code&gt;tileB&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;连接&lt;code&gt;tileA&lt;/code&gt;和&lt;code&gt;tileB&lt;/code&gt;，把刚连接的Room加入&lt;code&gt;connectedRooms&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;重复步骤2，直到所有房间都和mainRoom相连。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void ConnectClosestRooms(List&amp;lt;Room&amp;gt; allRooms) {
    int bestDistance = 0;
    Coord bestTileA = new Coord();
    Coord bestTileB = new Coord();
    Room bestRoomA = new Room();
    Room bestRoomB = new Room();
    bool possibleConnectionFound = false;

    foreach (Room roomA in allRooms) {
        possibleConnectionFound = false;

        foreach (Room roomB in allRooms) {
            if (roomA == roomB) {
                continue;
            }

            if (roomA.isConnected(roomB)) {
                possibleConnectionFound = false;
                break;
            }

            for (int tileIndexA = 0; tileIndexA &amp;lt; roomA.edgeTiles.Count; tileIndexA++) {
                for (int tileIndexB = 0; tileIndexB &amp;lt; roomB.edgeTiles.Count; tileIndexB++) {
                    Coord tileA = roomA.edgeTiles[tileIndexA];
                    Coord tileB = roomB.edgeTiles[tileIndexB];
                    int distanceBetweenRooms = (int)(Mathf.Pow(tileA.tileX - tileB.tileX, 2) + Mathf.Pow(tileA.tileY - tileB.tileY, 2));
                    if (distanceBetweenRooms &amp;lt; bestDistance || !possibleConnectionFound) {
                        bestDistance = distanceBetweenRooms;
                        possibleConnectionFound = true;
                        bestTileA = tileA;
                        bestTileB = tileB;
                        bestRoomA = roomA;
                        bestRoomB = roomB;
                    }
                }
            }
        }

        if (possibleConnectionFound) {
            CreatePassage(bestRoomA, bestRoomB, bestTileA, bestTileB);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入了上面的处理，最终结果如下图所示：
&lt;img src=&#34;https://samsonchen1989.github.io/img/proc2_6.png&#34; alt=&#34;所有房间通过连接到主房间，确保房间贯通&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;结尾&#34;&gt;结尾&lt;/h4&gt;

&lt;p&gt;总结下Room的处理流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用Flood Fill方法选出房间集合和墙区域的集合。&lt;/li&gt;
&lt;li&gt;设定阈值，清除过小的墙和房间。&lt;/li&gt;
&lt;li&gt;获取房间列表，两两连接最接近房间。&lt;/li&gt;
&lt;li&gt;获取主房间，确保所有房间都连接到主房间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;处理好了路径，接下来的工作就是处理map数组，把路径描绘出来，这个涉及到一些新的概念，可以下一章单独聊。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;本篇内容包含&lt;a href=&#34;https://www.youtube.com/playlist?list=PLFt_AvWsXl0eZgMK_DT5_biRkWXftAOf9&#34;&gt;Procedural Cave Generation&lt;/a&gt;系列视频教程的&lt;a href=&#34;https://www.youtube.com/watch?v=xYOG8kH2tF8&amp;amp;index=5&amp;amp;list=PLFt_AvWsXl0eZgMK_DT5_biRkWXftAOf9&#34;&gt;第5章&lt;/a&gt;，&lt;a href=&#34;https://www.youtube.com/watch?v=eVb9kQXvEZM&amp;amp;index=6&amp;amp;list=PLFt_AvWsXl0eZgMK_DT5_biRkWXftAOf9&#34;&gt;第6章&lt;/a&gt;和&lt;a href=&#34;https://www.youtube.com/watch?v=NhMriRLb1fs&amp;amp;list=PLFt_AvWsXl0eZgMK_DT5_biRkWXftAOf9&amp;amp;index=7&#34;&gt;第7章&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;源代码可参考SebLague小哥的Github，&lt;a href=&#34;https://github.com/SebLague/Procedural-Cave-Generation&#34;&gt;戳我直达&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>从Dota2的伪随机谈开</title>
      <link>https://samsonchen1989.github.io/post/random/</link>
      <pubDate>Tue, 27 Sep 2016 17:27:36 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/random/</guid>
      <description>

&lt;p&gt;起因是在知乎上看到木七七工作室转发的&lt;a href=&#34;https://zhuanlan.zhihu.com/p/22630963&#34;&gt;谈随机处理的一个内部视频&lt;/a&gt;，木七七本来是一个做Flash游戏分享和页游的公司，跟着手游浪潮，把旗下的《像素骑士团》改头换面成手游版《冒险与挖矿》大获成功（虽然有角川书店的正版授权，但游戏内容大部分打的都是集英社，讲谈社的擦边球，比如鸣人改名成吊车尾少年，后期版本还改了颜色避嫌）。不谈这些八卦，毕竟在国内要找不偷腥的猫还是很困难的，mu77知乎上的专栏从运营到策划，还是干货满满，推荐有兴趣的人关注下。&lt;/p&gt;

&lt;p&gt;视频里面聊到Dota2的技能概率处理方式，比如大鱼人（Sorry好久没玩Dota了已经想不起来这位的真名）的被动技能升满后：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次攻击有25%的几率让敌人眩晕。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般做法用&lt;strong&gt;纯随机 True random distribution&lt;/strong&gt;的方式，每次攻击时计算概率，独立判断是否触发眩晕。不过可能会出现一些体验问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;因为每次独立计算概率，极限情况会导致一直触发眩晕和一直不触发，间接造成欧皇和非洲酋长之间的战争。&lt;/li&gt;
&lt;li&gt;从玩家体验上来说，感官上25%的几率，超过5，6次不触发，他就会开始怀疑几率是否被策划运营篡改，幕后是否有肮脏的PY交易，而不是回想下初中的数学课。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;纯随机在数学上是无罪的，机器底层的随机函数是清白的（其实也不是那么清白，毕竟&lt;strong&gt;纯随机是不存在的&lt;/strong&gt;，不过这个就扯深了，先默认一般的random接口函数就是纯随机），但是有些时候并不是最佳解决方案。&lt;/p&gt;

&lt;h3 id=&#34;用伪随机分布pseudo-random-distribution处理概率&#34;&gt;用伪随机分布Pseudo-random distribution处理概率&lt;/h3&gt;

&lt;p&gt;Dota2的伪随机分布采用概率补偿的方式，每次触发概率从一个值开始递增，第N次的触发概率P(N) = C * N，比如25%的几率，C值大概为8.5%，运算流程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;第一次触发眩晕概率为8.5%&lt;/li&gt;
&lt;li&gt;第二次为17%，以此类推递增&lt;/li&gt;
&lt;li&gt;如果触发眩晕成功，则概率重新从8.5%开始递增计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方式使得连续触发或连续不触发的几率降低，避免了运气成分过于影响战斗结果（特别是竞技游戏）。&lt;/p&gt;

&lt;p&gt;一般几率对应的C值可以参考下面这张图。P(T)代表预期值，就是游戏中显示的几率值。P(A)是用了伪随机后的实际概率。MaxN表示最坏情况下触发概率的次数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/rpic1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;计算C值的方式和程序实现可以参考&lt;a href=&#34;http://gaming.stackexchange.com/questions/161430/calculating-the-constant-c-in-dota-2-pseudo-random-distribution&#34;&gt;这个链接&lt;/a&gt;下的回答，有C#的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;//CfromP是主函数，传入理论概率P就可以求得递增的C值
public decimal CfromP( decimal p )
{
    decimal Cupper = p;
    decimal Clower = 0m;
    decimal Cmid;
    decimal p1;
    decimal p2 = 1m;
    while(true)
    {
        Cmid = ( Cupper + Clower ) / 2m;
        p1 = PfromC( Cmid );
        if ( Math.Abs( p1 - p2 ) &amp;lt;= 0m ) break;

        if ( p1 &amp;gt; p )
        {
            Cupper = Cmid;
        }
        else
        {
            Clower = Cmid;
        }

        p2 = p1;
    }

    return Cmid;
}

private decimal PfromC( decimal C )
{
    decimal pProcOnN = 0m;
    decimal pProcByN = 0m;
    decimal sumNpProcOnN = 0m;

    int maxFails = (int)Math.Ceiling( 1m / C );
    for (int N = 1; N &amp;lt;= maxFails; ++N)
    {
        pProcOnN = Math.Min( 1m, N * C ) * (1m - pProcByN);
        pProcByN += pProcOnN;
        sumNpProcOnN += N * pProcOnN;
    }

    return ( 1m / sumNpProcOnN );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的伪随机分布算是用概率补偿的方式控制概率来改善玩家的体验，详细的可以参考&lt;a href=&#34;http://dota2.gamepedia.com/Pseudo-random_distribution&#34;&gt;Dota2的Wiki&lt;/a&gt;（打Dota2，向冰蛙学数学）。&lt;/p&gt;

&lt;p&gt;当然也有其他方式控制随机数和概率，正好前一阵子看了一个&lt;a href=&#34;http://www.redblobgames.com/articles/probability/damage-rolls.html&#34;&gt;从D&amp;amp;D掷骰角度谈控制随机分布&lt;/a&gt;的文章，下面也算一个翻译和整理。&lt;/p&gt;

&lt;h3 id=&#34;我这把可是1d2有毒的飞刀&#34;&gt;我这把可是1d2有毒的飞刀&lt;/h3&gt;

&lt;p&gt;D&amp;amp;D里面&lt;strong&gt;NdS&lt;/strong&gt;表示投掷S面的骰子N次，累加结果。比如1d12表示投掷一个12面骰子一次，3d4表示投掷一个4面骰子3次。&lt;/p&gt;

&lt;p&gt;假设我们要获取[0,24]之间的随机值，可以先设置一个函数rollDice(N, S)来模拟骰子投掷：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static int rollDice(int N, int S) {
    int value = 0;
    for (int i = 0; i &amp;lt; N; i++) {
        //每次随机结果为[0, S]
        value += Random.Range(0, S + 1);
    }

    return value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以rollDice(1,24)，也可以拆分成2次，变成rollDice(2,12)，变成两次[0,12]的和，以此类推rollDice(3,8)、rollDice(4,6)，下面这张图可以看到最终结果的分布变化：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/rpic5.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到投掷的次数越多，最终结果分布就越集中在[0,24]的平均值附近，所以4d6的武器比3d8的武器输出更平稳，但3d8的武器造成高伤害的几率也更高。&lt;/p&gt;

&lt;p&gt;除了控制随机取值的集中区域，我们还可以用简单的方式控制随机取值是&lt;strong&gt;大部分分散在平均值以下&lt;/strong&gt;还是&lt;strong&gt;大部分分散在平均值以上&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&#34;两次随机取较大-较小值&#34;&gt;两次随机取较大/较小值&lt;/h5&gt;

&lt;p&gt;还是以取[0,24]之间随机值为例，每次rollDice(2,12)两次，取较大值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int roll1 = rollDice(2, 12);
int roll2 = rollDice(2, 12);
int result = Math.Max(roll1,  roll2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分布图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/rpic2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;反过来，取较小值，可以获得集中在平均值以下的分布：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-chsarp&#34;&gt;int roll1 = rollDice(2, 12)
int roll2 = rollDice(2, 12)
int result = Math.Min(roll1, roll2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/rpic4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取较小值在计算伤害值比较常见，比如一个角色的攻击力在20到40之间，利用这种方法可以使得最后结果集中在较低的范围，高伤害出现的几率较低。&lt;/p&gt;

&lt;h5 id=&#34;三次随机取较大的两个值&#34;&gt;三次随机取较大的两个值&lt;/h5&gt;

&lt;p&gt;rollDice(1,12)三次，取较大的两个值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-chsarp&#34;&gt;int roll1 = rollDice(1, 12);
int roll2 = rollDice(1, 12);
int roll3 = rollDice(1, 12);

int result = roll1 + roll2 + roll3;
result = result - Math.Min(roll1, roll2, roll3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分布图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/rpic3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出比两次取较大/较小值分布更为平滑。&lt;/p&gt;

&lt;p&gt;总结一下，可以看到在控制某个范围内随机数时，可以从下面几个角度进行自定义以满足需求：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;范围&lt;/strong&gt;。确定随机范围的最大值和最小值，如果需要可以做一些偏移，比如[20, 30]可以分解为20 + rollDice(1, 10)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方差&lt;/strong&gt;。将一次随机分解为多次随机，可以使结果更靠近中间值。相反，次数越少，结果分布范围越广。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不对称性&lt;/strong&gt;。可以通过上面介绍的两种方法，使随机结果更多分布在平均值之前或者之后。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;自定义概率分布&#34;&gt;自定义概率分布&lt;/h3&gt;

&lt;p&gt;很多情况下，策划过来找你的时候，情景有可能是：我这里有10种掉落物品，每种的掉率我都想单独配置，比如A掉率10%，B掉率20%等等和一个Excel文件。&lt;/p&gt;

&lt;p&gt;最终的配置文件可能是像这样一个数组，前面是掉率（以100算100%），后面跟着物品ID。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local dropRate = {
    {10, 100001},
    {20, 100002},
    {30, 100003},
    {40, 100004},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;掉率的总和不一定正好是100，毕竟要考虑些对配置文件的容错性，所以先算出概率和sumRate，取random(sumRate)的值value，依次遍历dropDate表，累加概率和weight，如果value小于等于weight，则算是落在当前区间，返回对应的物品ID。我用lua写了一段测试代码，毕竟lua的table实在是太方便了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local dropRate = {
    {10, 100001},
    {20, 100002},
    {30, 100003},
    {40, 100004},
}

local distribute = {
    [100001] = 0,
    [100002] = 0,
    [100003] = 0,
    [100004] = 0,
}

local checkRate = function(t, value)
    local weight = 0
    for i=1,#t do
        weight = weight + t[i][1]
        if value &amp;lt;= weight then
            return t[i][2]
        end
    end

    return nil
end

local getDropItem = function(t)
    local weightTotal = 0
    for k,v in pairs(t) do
        weightTotal = weightTotal + v[1]
    end

    local value = math.random(weightTotal)

    return checkRate(t, value)
end

local main = function()
    --用倒序时间设置random的seed，确保seed随时间显著变化
    math.randomseed(tostring(os.time()):reverse():sub(1, 6))

    for i=1,10000 do
        local id = getDropItem(dropRate)
        if id and distribute[id] then
            distribute[id] = distribute[id] + 1
        end
    end

    for index,dis in pairs(distribute) do
        print(&amp;quot;index:&amp;quot;,index)
        print(&amp;quot;dis:&amp;quot;,dis)
        print(&amp;quot;percent:&amp;quot;,dis / 10000)
        print(&amp;quot;=================&amp;quot;)
    end
end

main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果和配置概率很接近，这样就可以让策划尽情发挥他的奇怪掉率了。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;上面的部分只是最近看到的一些有意思的随机数讨论整理，真正在实际项目中，随机数的处理是跟随不同的需求做变化的，随机可以增加游戏过程的乐趣，可以给游戏增加卖点，也可以变成各种“坑”，对于开发来说，只要这个坑是可控制的，不要坑到自己就行了~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>程序生成地下城(1) #整理 #翻译 #Unity</title>
      <link>https://samsonchen1989.github.io/post/proc1/</link>
      <pubDate>Fri, 23 Sep 2016 09:19:43 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/proc1/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;原始资料是油管上的视频教程，&lt;a href=&#34;https://www.youtube.com/playlist?list=PLFt_AvWsXl0eZgMK_DT5_biRkWXftAOf9&#34;&gt;链接戳我&lt;/a&gt;，播主是南非小哥&lt;a href=&#34;https://twitter.com/SebastianLague&#34;&gt;Sebastian Lague&lt;/a&gt;，专门在油管上做Procedural Generation和Unity的相关教程视频。Unity官方也把这个系列加到了&lt;a href=&#34;https://unity3d.com/learn/tutorials/projects/procedural-cave-generation-tutorial&#34;&gt;推荐教程中&lt;/a&gt;。&amp;rdquo;Procedural Cave Generation&amp;rdquo;这个系列已经完结，自己跟着后面做了一遍，收获颇多，这里做个整理和翻译，也算帮助自己理解。他还有一个正在连载的系列“Landmass Generation”，动态生成3D Terrain，等完结了也可以考虑做个整理。
这个整理以理解和介绍背景知识为主，会贴部分代码，想看详细代码的可以看他的&lt;a href=&#34;https://github.com/SebLague/Procedural-Cave-Generation&#34;&gt;Github项目主页&lt;/a&gt;。部分代码小哥是一笔带过，可能看完你知道怎么做，但为什么这么做理解起来可能有些困难，我也尽量找出相关资料辅助理解，Let&amp;rsquo;s Start!&lt;/p&gt;

&lt;h2 id=&#34;cellular-automata-细胞自动机&#34;&gt;Cellular automata(细胞自动机)&lt;/h2&gt;

&lt;p&gt;Cellular Automata最早是冯诺曼依大爷提出的离散数学模型，详细的信息可以参考&lt;a href=&#34;https://en.wikipedia.org/wiki/Cellular_automaton&#34;&gt;Wiki&lt;/a&gt;，在洞穴生成里面我们只需要借鉴这个模型的三个特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个由多个格子Cell组成的N维网格（这里只要用到2维网格）&lt;/li&gt;
&lt;li&gt;每格Cell状态有限（这里只取两个状态，每格值是0-空地，或者1-墙）&lt;/li&gt;
&lt;li&gt;网格按照某种规则演变，每格Cell状态变化受周围格子状态的影响而变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;背景知识就介绍这么多，接下来开始一步步实现。&lt;/p&gt;

&lt;h2 id=&#34;随机生成2维网格&#34;&gt;随机生成2维网格&lt;/h2&gt;

&lt;p&gt;根据上面介绍的Cellular automata第一和第二条规则，在Unity中建立一个脚本&amp;rdquo;MapGenerator&amp;rdquo;负责二维网格的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public int width;
public int height;

public string seed;
public bool useRandomSeed;

[Range(0,100)]
public int randomFillPercent;

int[,] map;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;width和height为可设置的地图大小。生成地图的规则也很简单，设置一个randomFillPercent值，对每一点进行遍历，随机取值，如果小于randomFillPercent，将该点设置为1，否则设置为0。一般设置randomFillPercent为50左右。
考虑到有时候我们需要能够存储和重新生成相同的地图，所以在初始化网格时并不是完全随机，而是设置一个seed，进行伪随机生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void RandomFillMap() {
    if (useRandomSeed) {
        seed = Time.time.ToString();
    }

    System.Random pseudoRandom = new System.Random(seed.GetHashCode());

    for (int x = 0; x &amp;lt; width; x ++) {
        for (int y = 0; y &amp;lt; height; y ++) {
            if (x == 0 || x == width-1 || y == 0 || y == height -1) {
                map[x,y] = 1; //设置边缘固定为墙
            } else {
                map[x,y] = (pseudoRandom.Next(0,100) &amp;lt; randomFillPercent)? 1 : 0;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/pic2.jpg&#34; alt=&#34;&#34; /&gt;
首次生成的图可能是这个样子，别着急，接下来根据Cellular Automata的第三个特征处理网格。&lt;/p&gt;

&lt;h2 id=&#34;应用规则处理网格&#34;&gt;应用规则处理网格&lt;/h2&gt;

&lt;p&gt;Cellular Automata网格的处理规则并不是固定的，比较经典的如&lt;a href=&#34;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&#34;&gt;Conway&amp;rsquo;s Game of Life生命游戏的规则&lt;/a&gt;，不过我们这里处理规则比较简单：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;统计当前格子Cell周围8个网格状态为1（墙）的总和S&lt;/li&gt;
&lt;li&gt;如果S大于4，则把Cell设为1。如果S小于4，则把Cell设为0。&lt;/li&gt;
&lt;li&gt;如果S等于4，则Cell值保持不变。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void SmoothMap() {
    for (int x = 0; x &amp;lt; width; x ++) {
        for (int y = 0; y &amp;lt; height; y ++) {
            int neighbourWallTiles = GetSurroundingWallCount(x,y);

            if (neighbourWallTiles &amp;gt; 4)
                map[x,y] = 1;
            else if (neighbourWallTiles &amp;lt; 4)
                map[x,y] = 0;

        }
    }
}

int GetSurroundingWallCount(int gridX, int gridY) {
    int wallCount = 0;
    for (int neighbourX = gridX - 1; neighbourX &amp;lt;= gridX + 1; neighbourX ++) {
        for (int neighbourY = gridY - 1; neighbourY &amp;lt;= gridY + 1; neighbourY ++) {
            if (IsInMapRange(neighbourX, neighbourY)) {
                // 统计周围8个点的情况，请参考Moore neighborhood(https://en.wikipedia.org/wiki/Moore_neighborhood)
                if (neighbourX != gridX || neighbourY != gridY) {
                    wallCount += map[neighbourX, neighbourY];
                }
            }
            else {
                wallCount ++;
            }
        }
    }

    return wallCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;循环上述步骤&lt;strong&gt;5&lt;/strong&gt;次，可以看到地图的变化如下：
&lt;img src=&#34;https://samsonchen1989.github.io/img/pic1.jpg&#34; alt=&#34;可以看到整个网格变得越来越聚拢规整&#34; /&gt;
如果你对其他处理规则感兴趣，可以查阅下面两个链接：&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;https://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664&#34;&gt;Generate Random Cave Levels Using Cellular Automata&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.raywenderlich.com/66062/procedural-level-generation-games-using-cellular-automaton-part-1&#34;&gt;Procedural Level Generation in Games using a Cellular Automaton&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;规则是先设定一个DeathLimit（如3）和BirthLimit（如4）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;统计当前Cell周围为1（墙）的值S&lt;/li&gt;
&lt;li&gt;如果Cell为1（墙），S值小于DeathLimit，则设置Cell为0&lt;/li&gt;
&lt;li&gt;如果Cell为0（空地），S值大于BirthLimit，则设Cell为1&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;需要解决的问题&#34;&gt;需要解决的问题&lt;/h2&gt;

&lt;p&gt;虽然目前可以生成一个卖相不错的地图，但还存留一些问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;地图中依然存在小块的空地集合或墙集合。&lt;/li&gt;
&lt;li&gt;大块的空地并不确保互相连通。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要解决这两个问题，可以参考下面这篇文章，在生成规则上做一些优化&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels&#34;&gt;Cellular Automata Method for Generating Random Cave-Like Levels&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;也可以参考Procedural Cave Generation这个系列教程里，Sebastian小哥引入的“房间Room”的概念，去除过小的房间，然后对空房间进行连接，这个是part2要讲的部分。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：原始教程中，讲完本文的内容，Sebastian小哥先去讲了怎么在Unity里生成二维网格的Mesh，然后再回头讲房间连接，这里我先换个顺序，把和网格处理相关的内容一块说了，再把Mesh生成放到最后说。&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>也谈No Man&#39;s Sky</title>
      <link>https://samsonchen1989.github.io/post/nms/</link>
      <pubDate>Mon, 15 Aug 2016 18:49:00 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/nms/</guid>
      <description>&lt;p&gt;如果二十年前有人说自己的游戏里面可以有18,446,744,073,709,551,616（其实就是&lt;strong&gt;2^64&lt;/strong&gt;）颗不同的星球，每个星球有自己独特的地貌、环境、生物甚至独特的食物链，你一定会觉得他是被那些节奏诡异闪着《电子世界争霸战》癫狂游离光线的游戏闪傻了。不过2年前《No Man&amp;rsquo;s Sky》在E3上展出的时候，没有人觉得这个是玩笑，只是有点将信将疑——这个当时还只有4个人的工作室&lt;strong&gt;Hello Games&lt;/strong&gt;会把这款号称无限可能的游戏推到什么样的高度。&lt;/p&gt;

&lt;p&gt;《No Man&amp;rsquo;s Sky》初始版本才3.4个G，但丝毫不影响他模拟星球的能力。在强大的硬件机能支撑下，Procedural Generation变得离玩家越来越近。随着Rougelike类型游戏的流行，很多游戏中的关卡不再是一成不变只要背板就能通过，而是每次随机生成确保每次游戏都有独一无二的体验，比较典型的像《以撒的结合》关卡，但严格意义上来说市面上大部分的Rougelike游戏并不算纯粹的程序生成。依然需要关卡设计师来创造一些基本的地图，然后用伪随机的方式（参见以撒中的Seed）选取地图和怪物进行拼接和配置。&lt;/p&gt;

&lt;p&gt;Unity里一种伪随机数的实现方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;    // Unity params
    public bool useRandomSeed;

    // When use pseudo random
    if (useRandomSeed) {
        seed = Time.time.ToString();
    }

    System.Random pseudoRandom = new System.Random(seed.GetHashCode());
    // In a loop
    for () {
        pseudoRandom.Next(0,100)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;《No Man&amp;rsquo;s Sky》把Procedural Generation在游戏中的应用又提升到一个新的高度，大到星球的地表，小到生物的音效，全部都是由程序按照一定的规则生成。在大部分的Procedural Generation实验里，这些规则都是无序或者散乱的，但是在无人深空里，这套规则，按照制作组的野心，就是尽量模拟靠近宇宙自然的规则，从气候-&amp;gt;资源-&amp;gt;地形-&amp;gt;食物链-&amp;gt;生物，一层以一层为基础迭代而来，这才形成了一个独一无二的星球。&lt;/p&gt;

&lt;p&gt;当然，野心归野心，从技术角度，NMS的完成度是比较高和有先驱性的，但是作为一个游戏，把所有的生成交给电脑，玩家会有意外的惊喜，但也容易被可能重复的内容磨掉兴趣，让他们觉得“都是套路”。毕竟规则是有限的，有很多人喜欢设计出的惊喜和设计出的情绪调动，而不喜欢冷冰冰的电脑。&lt;/p&gt;

&lt;p&gt;从目前的评测来看，NMS的Procedural Generation主要集中在图形和音效上，但在系统和AI上没有什么建树，贸易系统和NPC系统都很初级，喜欢玩太空4X类游戏的人估计也没法再这个游戏里找到自己的点，因为他只有eXplore和eXploit，却没有eXpand和eXterminate。&lt;/p&gt;

&lt;p&gt;说到底，这个游戏只是一个程序员们的自然模拟实验，被过于放在聚光灯和舆论中曝光了。战斗，交易，飞船只是附属品，这个游戏的核心在于探索，但大部分人并不在意自己能发现啥，也没有耐心细细地探索每个世界。这个游戏并不适合所有的玩家，这个纯粹由程序和数学构建的游戏，没有刻意的包装和讨好，就像一杯纯净水，拥有无限的形态和可能性，但不可口。&lt;/p&gt;

&lt;p&gt;按照现在3A游戏的开发成本和已经不像以前那样饥不择食的玩家，纯PVE和关卡设计的游戏越来越捉襟见肘&lt;del&gt;如果能达到像Limbo和Inside那种设计高度当我没说&lt;/del&gt;PVP（守望屁股），Rougelike（以撒），类Minecraft和Procedural Generation（无人深空）类型的游戏更容易脱颖而出。很多人说NMS吹牛吹破了天，我倒觉得从4个人到20个人，Hello Game小作坊能花三年做到这样的完成度，已经很了不起了。在技术的实验探索上，也不知道比国内某些冷嘲热讽的开发者高到哪里去。&lt;/p&gt;

&lt;p&gt;这里有一篇比较专业的评测，有兴趣可以看看：&lt;a href=&#34;http://www.makeuseof.com/tag/no-mans-sky-future-procedural-games/&#34;&gt;No Man’s Sky and the Future of Procedural Games&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这位大哥受无人深空启发，做了一个&lt;a href=&#34;https://marian42.github.io/proceduralart/&#34;&gt;2D的星球版画生成器&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有关音乐音效</title>
      <link>https://samsonchen1989.github.io/post/blog2/</link>
      <pubDate>Tue, 02 Aug 2016 20:56:09 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/blog2/</guid>
      <description>&lt;p&gt;国内的公司对音效音乐啥的不怎么重视，可能一个稍微大点的公司里只有一个人来负责音效音乐的……嗯，外包接洽工作，而那些无良的外包公司七拼八凑一些音效就扔给你。一个活例子就是我们找了家特便宜的音效外包，结果直到老外玩家给了差评才发现，给过来的战斗胜利音效竟然和COC一模一样。&lt;/p&gt;

&lt;p&gt;相反，去KS上筹钱的项目里，四五个人的团队介绍里面总会有一个妹子或者花臂大哥，title是音乐音效指导，作曲家。Steam上很多游戏的唯一DLC就是Soundtrack原声包，还价格不菲。&lt;/p&gt;

&lt;p&gt;没办法，这就是做方便面和担仔面，批发调料包和自己炖浇头的区别。之所以想到这个比方是因为上周去大悦城吃了一家叫“度小月”台湾面，味道还不错，就是量太少了，一碗根本不够吃。这也或许是为啥玩家还是会对各种流水线商业游戏趋之若鹜，按照Limbo和Inside这家工作室的开发速度，艺术游戏和精良的个人游戏是喂不饱疯狂的&lt;del&gt;特别闲的&lt;/del&gt;玩家的。&lt;/p&gt;

&lt;p&gt;为了证明上面的问题，拆了COC的包，顺便看了看它的音乐文件格式：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;音乐文件格式&lt;/th&gt;
&lt;th&gt;音效文件格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Android&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.mp3&lt;/strong&gt;(比特率&lt;strong&gt;64kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.ogg&lt;/strong&gt;(比特率&lt;strong&gt;32~42kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;iOS&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.mp3&lt;/strong&gt;(比特率&lt;strong&gt;64kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.caf&lt;/strong&gt;(比特率&lt;strong&gt;32kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;一般现在的游戏引擎都会把音乐和音效的播放分开，音乐同一时间只能播放一个，音效可以同时播放多个，但也有例外，比如针对三星的一些Android机型，同时播放多个音效文件会造成明显的卡顿，所以需要一个计时器来限定下单位时间内播放音效的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;AudioManager.repeatSfx = {}

local function limitSoundPlay(sfx_name)
  if AudioManager.repeatSfx[sfx_name] or table.nums(AudioManager.repeatSfx) &amp;gt; 2 then
    return true
  end

  AudioManager.repeatSfx[sfx_name] = scheduler.performWithDelayGlobal(function()
    AudioManager.repeatSfx[sfx_name] = nil
  end,0.3)

  return false
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>cocos2dx UI的一些碎碎念</title>
      <link>https://samsonchen1989.github.io/post/blog1/</link>
      <pubDate>Thu, 28 Jul 2016 23:00:12 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/blog1/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;一不小心也做了快两年游戏程序了，主程，我，服务器小哥三个程序996了一年多，自己主要做地图探索，陷阱机关的GamePlay，成就，和其他各式各样的纯UI系统。个人理想中的配置应该是三个客户端和两个服务器，可惜现实很骨感，小公司成本有限，基本都是谁有空就接着往下做，还要和主程抢服务器小哥做对接，不过也算有始有终，游戏总算上线稳定运行了。&lt;/p&gt;

&lt;p&gt;小公司的工作是人驱动的，大公司是流程驱动的，各有利弊。以前在TP的时候，工作都是邮件驱动，产品部的发邮件给组长，一群人先文字讨论半天，然后把你加进来，可能只是改个字而已。现在策划提个简单的需求，只要喊一声，半个小时后就能做完出结果了，非常快捷，不需要走流程。当然弊端也有，比如缺乏记录和文档，可能过半年策划就记不起来自己当时为啥提这个需求了。规范化和流程化是必经之路，不过考虑到手游的开发周期，如何简化和平衡也是个问题。&lt;/p&gt;

&lt;p&gt;我们的游戏Heroes Quest在加拿大测试的时候，正好遇到皇室战争上架，然后7月初正式全球上的时候，又遇到了Pokemon Go这种怪物，所以定发布日期也是一种学问啊&lt;em&gt;(:зゝ∠)&lt;/em&gt;
&lt;a href=&#34;https://itunes.apple.com/app/id1118861621?mt=8&#34;&gt;App Store链接&lt;/a&gt;，&lt;a href=&#34;https://play.google.com/store/apps/details?id=com.heroesquest.rpg&#34;&gt;Google Play链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;虽然作为一个Unity党，对cocos2dx不怎么感冒，不过自己的喜好并不能影响到工作，有一些基本的原则和技巧是独立于工具或者引擎的，因为之前的博客跟着到期的vps随风而去了，所以最近打算把以前的一些工作总结一下，把博客搬到Gihub来，也算是新开始吧。&lt;/p&gt;

&lt;p&gt;UI方面的工作比较碎，比较单调，但也有很多讲究，合理的UI设计可以节省很多DrawCall和CPU的开销，这里总结一些Tips。&lt;/p&gt;

&lt;h2 id=&#34;需要时加载图集&#34;&gt;需要时加载图集&lt;/h2&gt;

&lt;p&gt;为了节省DrawCall一般会把相同界面或者相同类型的图片用TexturePacker打包成一张整图，比如通用的UI框体，按钮可以打包成一个图集。在每个场景创建前，加载一些必用图集，然后看情况加载其他图集。&lt;/p&gt;

&lt;p&gt;尽量把不同的窗口做成不同的Layer或Node，每个窗口管理自己所需要的图集，避免无用图集占用内存，做到&lt;strong&gt;需要时加载&lt;/strong&gt;。这点有点像Unity的&lt;strong&gt;组件化Component-Based&lt;/strong&gt;思想，尽量把重复的部分（甚至不重复的部分，你永远不会想到策划哪天会突发奇想，复用某一块界面）独立，然后按需加载。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;推荐图片格式&lt;/th&gt;
&lt;th&gt;推荐Pixel格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ios&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;pvr.ccz&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;PVRTC4&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Android&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;png和pvr.ccz&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;RGBA8888,RGBA4444加抖动&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;非透明图片采用&lt;strong&gt;JPG+RGB565&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详细的可以参考：
1. &lt;a href=&#34;http://blog.csdn.net/langresser_king/article/details/8426708&#34;&gt;iOS和android游戏纹理优化和内存优化(cocos2d-x)&lt;/a&gt;
2. &lt;a href=&#34;http://www.cocos.com/doc/tutorial/show?id=2902&#34;&gt;浅谈Cocos2d-x纹理优化&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;利用cache实现-只创建一次原则&#34;&gt;利用Cache实现“只创建一次原则”&lt;/h2&gt;

&lt;p&gt;一个稍微复杂的界面里，各个标签切换可能会产生大量的重复的Button、Label或者自定义Node，利用Cache把它们存储起来进行重复利用，可以减少明显的卡顿和不必要的GC。
一个Lua的简单实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;self.buttonCache = {
    buttonTable = {},
    index = 1,
    getButton = function()
        local index = self.buttonCache.index
        local button = self.buttonCache.buttonTable[index]
        if button then
            button:show()
        else
            button = WidgetHelper.quickItemWidget()
                :retain()
                :setAnchorPoint(0.5,0.5)
                :setTouchEnabled(true)
                :onTouch(handler(self,function(self,event) end))

            self.buttonCache.buttonTable[index] = button
        end

        self.buttonCache.index = self.buttonCache.index + 1
        return button
    end,

    recycleButton = function()
        for k,v in pairs(self.buttonCache.buttonTable) do
            v:removeFromParent()
            v:hide()
        end

        self.buttonCache.index = 1
    end,

    releaseButton = function()
        for k,v in pairs(self.buttonCache.buttonTable) do
            v:release()
        end
    end,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取Button的时候只用调用&lt;strong&gt;getButton()&lt;/strong&gt;，在切换标签或清空列表时调用&lt;strong&gt;recycleButton()&lt;/strong&gt;回收Button并重新计数，在退出Scene的时候调用&lt;strong&gt;releaseButton()&lt;/strong&gt;清除Cache。&lt;/p&gt;

&lt;p&gt;不单单是Button，任何重复的组件都可以用类似的格式进行Cache存储和重复利用，可以节省一大笔创建和销毁的开销。
需要注意的是，Cache中的元素，在重复利用时要做好检查，避免出现重复添加子节点，Enable状态没有重置等问题。&lt;/p&gt;

&lt;h2 id=&#34;提供统一的ui控件创建接口&#34;&gt;提供统一的UI控件创建接口&lt;/h2&gt;

&lt;p&gt;游戏中最常见的组件，物品道具Button，TTFLabel文本，HtmlLabel文本，RichText文本，采用统一的接口创建。保持格式统一，减少重复代码。特别是物品Button，一般是一个Button底加Icon Sprite加数量Label的组合，提供一个统一接口，处理不同Item的样式，比如装备的彩色底框，碎片的角标，人物头像的星级等等，做到传入一个Item ID和Type，就能产生相应的Button。&lt;/p&gt;

&lt;h2 id=&#34;延时加载&#34;&gt;延时加载&lt;/h2&gt;

&lt;p&gt;有时候运气比较背，一个列表里面要加载几十个子Node，每个Node上还都有动画和各种子Node，全部添加完需要2s左右，卡顿明显，除了怂恿策划美术改图之外，延时加载也是一个解决办法——不要等列表子Node加载完再显示，先显示列表，开一个计时器，每隔0.1s~0.2s添加一个子Node，在完全加载完前禁用用户交互，虽然时间差不多，但效果要明显好于让用户卡个几秒。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>