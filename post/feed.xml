<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Gamer Cat</title>
    <link>https://samsonchen1989.github.io/post/</link>
    <description>Recent content in Posts on Gamer Cat</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 23 Sep 2016 09:19:43 +0800</lastBuildDate>
    <atom:link href="https://samsonchen1989.github.io/post/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>程序生成地下城/洞穴(1) #整理 #翻译 #Unity</title>
      <link>https://samsonchen1989.github.io/post/proc1/</link>
      <pubDate>Fri, 23 Sep 2016 09:19:43 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/proc1/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;原始资料是油管上的视频教程，&lt;a href=&#34;https://www.youtube.com/playlist?list=PLFt_AvWsXl0eZgMK_DT5_biRkWXftAOf9&#34;&gt;链接戳我&lt;/a&gt;，播主是南非小哥&lt;a href=&#34;https://twitter.com/SebastianLague&#34;&gt;Sebastian Lague&lt;/a&gt;，专门在油管上做Procedural Generation和Unity的相关教程视频。Unity官方也把这个系列加到了&lt;a href=&#34;https://unity3d.com/learn/tutorials/projects/procedural-cave-generation-tutorial&#34;&gt;推荐教程中&lt;/a&gt;。&amp;rdquo;Procedural Cave Generation&amp;rdquo;这个系列已经完结，自己跟着后面做了一遍，收获颇多，这里做个整理和翻译，也算帮助自己理解。他还有一个正在连载的系列“Landmass Generation”，动态生成3D Terrain，等完结了也可以考虑做个整理。
这个整理以理解和介绍背景知识为主，会贴部分代码，想看详细代码的可以看他的&lt;a href=&#34;https://github.com/SebLague/Procedural-Cave-Generation&#34;&gt;Github项目主页&lt;/a&gt;。部分代码小哥是一笔带过，可能看完你知道怎么做，但为什么这么做理解起来可能有些困难，我也尽量找出相关资料辅助理解，Let&amp;rsquo;s Start!&lt;/p&gt;

&lt;h2 id=&#34;cellular-automata-细胞自动机&#34;&gt;Cellular automata(细胞自动机)&lt;/h2&gt;

&lt;p&gt;Cellular Automata最早是冯诺曼依大爷提出的离散数学模型，详细的信息可以参考&lt;a href=&#34;https://en.wikipedia.org/wiki/Cellular_automaton&#34;&gt;Wiki&lt;/a&gt;，在洞穴生成里面我们只需要借鉴这个模型的三个特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个由多个格子Cell组成的N维网格（这里只要用到2维网格）&lt;/li&gt;
&lt;li&gt;每格Cell状态有限（这里只取两个状态，每格值是0-空地，或者1-墙）&lt;/li&gt;
&lt;li&gt;网格按照某种规则演变，每格Cell状态变化受周围格子状态的影响而变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;背景知识就介绍这么多，接下来开始一步步实现。&lt;/p&gt;

&lt;h2 id=&#34;随机生成2维网格&#34;&gt;随机生成2维网格&lt;/h2&gt;

&lt;p&gt;根据上面介绍的Cellular automata第一和第二条规则，在Unity中建立一个脚本&amp;rdquo;MapGenerator&amp;rdquo;负责二维网格的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public int width;
public int height;

public string seed;
public bool useRandomSeed;

[Range(0,100)]
public int randomFillPercent;

int[,] map;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;width和height为可设置的地图大小。生成地图的规则也很简单，设置一个randomFillPercent值，对每一点进行遍历，随机取值，如果小于randomFillPercent，将该点设置为1，否则设置为0。一般设置randomFillPercent为50左右。
考虑到有时候我们需要能够存储和重新生成相同的地图，所以在初始化网格时并不是完全随机，而是设置一个seed，进行伪随机生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void RandomFillMap() {
    if (useRandomSeed) {
        seed = Time.time.ToString();
    }

    System.Random pseudoRandom = new System.Random(seed.GetHashCode());

    for (int x = 0; x &amp;lt; width; x ++) {
        for (int y = 0; y &amp;lt; height; y ++) {
            if (x == 0 || x == width-1 || y == 0 || y == height -1) {
                map[x,y] = 1; //设置边缘固定为墙
            } else {
                map[x,y] = (pseudoRandom.Next(0,100) &amp;lt; randomFillPercent)? 1 : 0;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://samsonchen1989.github.io/img/pic2.jpg&#34; alt=&#34;&#34; /&gt;
首次生成的图可能是这个样子，别着急，接下来根据Cellular Automata的第三个特征处理网格。&lt;/p&gt;

&lt;h2 id=&#34;应用规则处理网格&#34;&gt;应用规则处理网格&lt;/h2&gt;

&lt;p&gt;Cellular Automata网格的处理规则并不是固定的，比较经典的如&lt;a href=&#34;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&#34;&gt;Conway&amp;rsquo;s Game of Life生命游戏的规则&lt;/a&gt;，不过我们这里处理规则比较简单：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;统计当前格子Cell周围8个网格状态为1（墙）的总和S&lt;/li&gt;
&lt;li&gt;如果S大于4，则把Cell设为1。如果S小于4，则把Cell设为0。&lt;/li&gt;
&lt;li&gt;如果S等于4，则Cell值保持不变。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void SmoothMap() {
    for (int x = 0; x &amp;lt; width; x ++) {
        for (int y = 0; y &amp;lt; height; y ++) {
            int neighbourWallTiles = GetSurroundingWallCount(x,y);

            if (neighbourWallTiles &amp;gt; 4)
                map[x,y] = 1;
            else if (neighbourWallTiles &amp;lt; 4)
                map[x,y] = 0;

        }
    }
}

int GetSurroundingWallCount(int gridX, int gridY) {
    int wallCount = 0;
    for (int neighbourX = gridX - 1; neighbourX &amp;lt;= gridX + 1; neighbourX ++) {
        for (int neighbourY = gridY - 1; neighbourY &amp;lt;= gridY + 1; neighbourY ++) {
            if (IsInMapRange(neighbourX, neighbourY)) {
                // 统计周围8个点的情况，请参考Moore neighborhood(https://en.wikipedia.org/wiki/Moore_neighborhood)
                if (neighbourX != gridX || neighbourY != gridY) {
                    wallCount += map[neighbourX, neighbourY];
                }
            }
            else {
                wallCount ++;
            }
        }
    }

    return wallCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;循环上述步骤&lt;strong&gt;5&lt;/strong&gt;次，可以看到地图的变化如下：
&lt;img src=&#34;https://samsonchen1989.github.io/img/pic1.jpg&#34; alt=&#34;可以看到整个网格变得越来越聚拢规整&#34; /&gt;
如果你对其他处理规则感兴趣，可以查阅下面两个链接：&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;https://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664&#34;&gt;Generate Random Cave Levels Using Cellular Automata&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.raywenderlich.com/66062/procedural-level-generation-games-using-cellular-automaton-part-1&#34;&gt;Procedural Level Generation in Games using a Cellular Automaton&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;规则是先设定一个DeathLimit（如3）和BirthLimit（如4）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;统计当前Cell周围为1（墙）的值S&lt;/li&gt;
&lt;li&gt;如果Cell为1（墙），S值小于DeathLimit，则设置Cell为0&lt;/li&gt;
&lt;li&gt;如果Cell为0（空地），S值大于BirthLimit，则设Cell为1&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;需要解决的问题&#34;&gt;需要解决的问题&lt;/h2&gt;

&lt;p&gt;虽然目前可以生成一个卖相不错的地图，但还存留一些问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;地图中依然存在小块的空地集合或墙集合。&lt;/li&gt;
&lt;li&gt;大块的空地并不确保互相连通。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要解决这两个问题，可以参考下面这篇文章，在生成规则上做一些优化&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels&#34;&gt;Cellular Automata Method for Generating Random Cave-Like Levels&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;也可以参考Procedural Cave Generation这个系列教程里，Sebastian小哥引入的“房间Room”的概念，去除过小的房间，然后对空房间进行连接，这个是part2要讲的部分。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：原始教程中，讲完本文的内容，Sebastian小哥先去讲了怎么在Unity里生成二维网格的Mesh，然后再回头讲房间连接，这里我先换个顺序，把和网格处理相关的内容一块说了，再把Mesh生成放到最后说。&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>也谈No Man&#39;s Sky</title>
      <link>https://samsonchen1989.github.io/post/nms/</link>
      <pubDate>Mon, 15 Aug 2016 18:49:00 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/nms/</guid>
      <description>&lt;p&gt;如果二十年前有人说自己的游戏里面可以有18,446,744,073,709,551,616（其实就是&lt;strong&gt;2^64&lt;/strong&gt;）颗不同的星球，每个星球有自己独特的地貌、环境、生物甚至独特的食物链，你一定会觉得他是被那些节奏诡异闪着《电子世界争霸战》癫狂游离光线的游戏闪傻了。不过2年前《No Man&amp;rsquo;s Sky》在E3上展出的时候，没有人觉得这个是玩笑，只是有点将信将疑——这个当时还只有4个人的工作室&lt;strong&gt;Hello Games&lt;/strong&gt;会把这款号称无限可能的游戏推到什么样的高度。&lt;/p&gt;

&lt;p&gt;《No Man&amp;rsquo;s Sky》初始版本才3.4个G，但丝毫不影响他模拟星球的能力。在强大的硬件机能支撑下，Procedural Generation变得离玩家越来越近。随着Rougelike类型游戏的流行，很多游戏中的关卡不再是一成不变只要背板就能通过，而是每次随机生成确保每次游戏都有独一无二的体验，比较典型的像《以撒的结合》关卡，但严格意义上来说市面上大部分的Rougelike游戏并不算纯粹的程序生成。依然需要关卡设计师来创造一些基本的地图，然后用伪随机的方式（参见以撒中的Seed）选取地图和怪物进行拼接和配置。&lt;/p&gt;

&lt;p&gt;Unity里一种伪随机数的实现方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;    // Unity params
    public bool useRandomSeed;

    // When use pseudo random
    if (useRandomSeed) {
        seed = Time.time.ToString();
    }

    System.Random pseudoRandom = new System.Random(seed.GetHashCode());
    // In a loop
    for () {
        pseudoRandom.Next(0,100)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;《No Man&amp;rsquo;s Sky》把Procedural Generation在游戏中的应用又提升到一个新的高度，大到星球的地表，小到生物的音效，全部都是由程序按照一定的规则生成。在大部分的Procedural Generation实验里，这些规则都是无序或者散乱的，但是在无人深空里，这套规则，按照制作组的野心，就是尽量模拟靠近宇宙自然的规则，从气候-&amp;gt;资源-&amp;gt;地形-&amp;gt;食物链-&amp;gt;生物，一层以一层为基础迭代而来，这才形成了一个独一无二的星球。&lt;/p&gt;

&lt;p&gt;当然，野心归野心，从技术角度，NMS的完成度是比较高和有先驱性的，但是作为一个游戏，把所有的生成交给电脑，玩家会有意外的惊喜，但也容易被可能重复的内容磨掉兴趣，让他们觉得“都是套路”。毕竟规则是有限的，有很多人喜欢设计出的惊喜和设计出的情绪调动，而不喜欢冷冰冰的电脑。&lt;/p&gt;

&lt;p&gt;从目前的评测来看，NMS的Procedural Generation主要集中在图形和音效上，但在系统和AI上没有什么建树，贸易系统和NPC系统都很初级，喜欢玩太空4X类游戏的人估计也没法再这个游戏里找到自己的点，因为他只有eXplore和eXploit，却没有eXpand和eXterminate。&lt;/p&gt;

&lt;p&gt;说到底，这个游戏只是一个程序员们的自然模拟实验，被过于放在聚光灯和舆论中曝光了。战斗，交易，飞船只是附属品，这个游戏的核心在于探索，但大部分人并不在意自己能发现啥，也没有耐心细细地探索每个世界。这个游戏并不适合所有的玩家，这个纯粹由程序和数学构建的游戏，没有刻意的包装和讨好，就像一杯纯净水，拥有无限的形态和可能性，但不可口。&lt;/p&gt;

&lt;p&gt;按照现在3A游戏的开发成本和已经不像以前那样饥不择食的玩家，纯PVE和关卡设计的游戏越来越捉襟见肘&lt;del&gt;如果能达到像Limbo和Inside那种设计高度当我没说&lt;/del&gt;PVP（守望屁股），Rougelike（以撒），类Minecraft和Procedural Generation（无人深空）类型的游戏更容易脱颖而出。很多人说NMS吹牛吹破了天，我倒觉得从4个人到20个人，Hello Game小作坊能花三年做到这样的完成度，已经很了不起了。在技术的实验探索上，也不知道比国内某些冷嘲热讽的开发者高到哪里去。&lt;/p&gt;

&lt;p&gt;这里有一篇比较专业的评测，有兴趣可以看看：&lt;a href=&#34;http://www.makeuseof.com/tag/no-mans-sky-future-procedural-games/&#34;&gt;No Man’s Sky and the Future of Procedural Games&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这位大哥受无人深空启发，做了一个&lt;a href=&#34;https://marian42.github.io/proceduralart/&#34;&gt;2D的星球版画生成器&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有关音乐音效</title>
      <link>https://samsonchen1989.github.io/post/blog2/</link>
      <pubDate>Tue, 02 Aug 2016 20:56:09 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/blog2/</guid>
      <description>&lt;p&gt;国内的公司对音效音乐啥的不怎么重视，可能一个稍微大点的公司里只有一个人来负责音效音乐的……嗯，外包接洽工作，而那些无良的外包公司七拼八凑一些音效就扔给你。一个活例子就是我们找了家特便宜的音效外包，结果直到老外玩家给了差评才发现，给过来的战斗胜利音效竟然和COC一模一样。&lt;/p&gt;

&lt;p&gt;相反，去KS上筹钱的项目里，四五个人的团队介绍里面总会有一个妹子或者花臂大哥，title是音乐音效指导，作曲家。Steam上很多游戏的唯一DLC就是Soundtrack原声包，还价格不菲。&lt;/p&gt;

&lt;p&gt;没办法，这就是做方便面和担仔面，批发调料包和自己炖浇头的区别。之所以想到这个比方是因为上周去大悦城吃了一家叫“度小月”台湾面，味道还不错，就是量太少了，一碗根本不够吃。这也或许是为啥玩家还是会对各种流水线商业游戏趋之若鹜，按照Limbo和Inside这家工作室的开发速度，艺术游戏和精良的个人游戏是喂不饱疯狂的&lt;del&gt;特别闲的&lt;/del&gt;玩家的。&lt;/p&gt;

&lt;p&gt;为了证明上面的问题，拆了COC的包，顺便看了看它的音乐文件格式：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;音乐文件格式&lt;/th&gt;
&lt;th&gt;音效文件格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Android&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.mp3&lt;/strong&gt;(比特率&lt;strong&gt;64kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.ogg&lt;/strong&gt;(比特率&lt;strong&gt;32~42kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;iOS&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.mp3&lt;/strong&gt;(比特率&lt;strong&gt;64kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;.caf&lt;/strong&gt;(比特率&lt;strong&gt;32kbps&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;一般现在的游戏引擎都会把音乐和音效的播放分开，音乐同一时间只能播放一个，音效可以同时播放多个，但也有例外，比如针对三星的一些Android机型，同时播放多个音效文件会造成明显的卡顿，所以需要一个计时器来限定下单位时间内播放音效的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;AudioManager.repeatSfx = {}

local function limitSoundPlay(sfx_name)
  if AudioManager.repeatSfx[sfx_name] or table.nums(AudioManager.repeatSfx) &amp;gt; 2 then
    return true
  end

  AudioManager.repeatSfx[sfx_name] = scheduler.performWithDelayGlobal(function()
    AudioManager.repeatSfx[sfx_name] = nil
  end,0.3)

  return false
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>cocos2dx UI的一些碎碎念</title>
      <link>https://samsonchen1989.github.io/post/blog1/</link>
      <pubDate>Thu, 28 Jul 2016 23:00:12 +0800</pubDate>
      
      <guid>https://samsonchen1989.github.io/post/blog1/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;一不小心也做了快两年游戏程序了，主程，我，服务器小哥三个程序996了一年多，自己主要做地图探索，陷阱机关的GamePlay，成就，和其他各式各样的纯UI系统。个人理想中的配置应该是三个客户端和两个服务器，可惜现实很骨感，小公司成本有限，基本都是谁有空就接着往下做，还要和主程抢服务器小哥做对接，不过也算有始有终，游戏总算上线稳定运行了。&lt;/p&gt;

&lt;p&gt;小公司的工作是人驱动的，大公司是流程驱动的，各有利弊。以前在TP的时候，工作都是邮件驱动，产品部的发邮件给组长，一群人先文字讨论半天，然后把你加进来，可能只是改个字而已。现在策划提个简单的需求，只要喊一声，半个小时后就能做完出结果了，非常快捷，不需要走流程。当然弊端也有，比如缺乏记录和文档，可能过半年策划就记不起来自己当时为啥提这个需求了。规范化和流程化是必经之路，不过考虑到手游的开发周期，如何简化和平衡也是个问题。&lt;/p&gt;

&lt;p&gt;我们的游戏Heroes Quest在加拿大测试的时候，正好遇到皇室战争上架，然后7月初正式全球上的时候，又遇到了Pokemon Go这种怪物，所以定发布日期也是一种学问啊&lt;em&gt;(:зゝ∠)&lt;/em&gt;
&lt;a href=&#34;https://itunes.apple.com/app/id1118861621?mt=8&#34;&gt;App Store链接&lt;/a&gt;，&lt;a href=&#34;https://play.google.com/store/apps/details?id=com.heroesquest.rpg&#34;&gt;Google Play链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;虽然作为一个Unity党，对cocos2dx不怎么感冒，不过自己的喜好并不能影响到工作，有一些基本的原则和技巧是独立于工具或者引擎的，因为之前的博客跟着到期的vps随风而去了，所以最近打算把以前的一些工作总结一下，把博客搬到Gihub来，也算是新开始吧。&lt;/p&gt;

&lt;p&gt;UI方面的工作比较碎，比较单调，但也有很多讲究，合理的UI设计可以节省很多DrawCall和CPU的开销，这里总结一些Tips。&lt;/p&gt;

&lt;h2 id=&#34;需要时加载图集&#34;&gt;需要时加载图集&lt;/h2&gt;

&lt;p&gt;为了节省DrawCall一般会把相同界面或者相同类型的图片用TexturePacker打包成一张整图，比如通用的UI框体，按钮可以打包成一个图集。在每个场景创建前，加载一些必用图集，然后看情况加载其他图集。&lt;/p&gt;

&lt;p&gt;尽量把不同的窗口做成不同的Layer或Node，每个窗口管理自己所需要的图集，避免无用图集占用内存，做到&lt;strong&gt;需要时加载&lt;/strong&gt;。这点有点像Unity的&lt;strong&gt;组件化Component-Based&lt;/strong&gt;思想，尽量把重复的部分（甚至不重复的部分，你永远不会想到策划哪天会突发奇想，复用某一块界面）独立，然后按需加载。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;推荐图片格式&lt;/th&gt;
&lt;th&gt;推荐Pixel格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ios&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;pvr.ccz&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;PVRTC4&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Android&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;png和pvr.ccz&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;RGBA8888,RGBA4444加抖动&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;非透明图片采用&lt;strong&gt;JPG+RGB565&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详细的可以参考：
1. &lt;a href=&#34;http://blog.csdn.net/langresser_king/article/details/8426708&#34;&gt;iOS和android游戏纹理优化和内存优化(cocos2d-x)&lt;/a&gt;
2. &lt;a href=&#34;http://www.cocos.com/doc/tutorial/show?id=2902&#34;&gt;浅谈Cocos2d-x纹理优化&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;利用cache实现-只创建一次原则&#34;&gt;利用Cache实现“只创建一次原则”&lt;/h2&gt;

&lt;p&gt;一个稍微复杂的界面里，各个标签切换可能会产生大量的重复的Button、Label或者自定义Node，利用Cache把它们存储起来进行重复利用，可以减少明显的卡顿和不必要的GC。
一个Lua的简单实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;self.buttonCache = {
    buttonTable = {},
    index = 1,
    getButton = function()
        local index = self.buttonCache.index
        local button = self.buttonCache.buttonTable[index]
        if button then
            button:show()
        else
            button = WidgetHelper.quickItemWidget()
                :retain()
                :setAnchorPoint(0.5,0.5)
                :setTouchEnabled(true)
                :onTouch(handler(self,function(self,event) end))

            self.buttonCache.buttonTable[index] = button
        end

        self.buttonCache.index = self.buttonCache.index + 1
        return button
    end,

    recycleButton = function()
        for k,v in pairs(self.buttonCache.buttonTable) do
            v:removeFromParent()
            v:hide()
        end

        self.buttonCache.index = 1
    end,

    releaseButton = function()
        for k,v in pairs(self.buttonCache.buttonTable) do
            v:release()
        end
    end,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取Button的时候只用调用&lt;strong&gt;getButton()&lt;/strong&gt;，在切换标签或清空列表时调用&lt;strong&gt;recycleButton()&lt;/strong&gt;回收Button并重新计数，在退出Scene的时候调用&lt;strong&gt;releaseButton()&lt;/strong&gt;清除Cache。&lt;/p&gt;

&lt;p&gt;不单单是Button，任何重复的组件都可以用类似的格式进行Cache存储和重复利用，可以节省一大笔创建和销毁的开销。
需要注意的是，Cache中的元素，在重复利用时要做好检查，避免出现重复添加子节点，Enable状态没有重置等问题。&lt;/p&gt;

&lt;h2 id=&#34;提供统一的ui控件创建接口&#34;&gt;提供统一的UI控件创建接口&lt;/h2&gt;

&lt;p&gt;游戏中最常见的组件，物品道具Button，TTFLabel文本，HtmlLabel文本，RichText文本，采用统一的接口创建。保持格式统一，减少重复代码。特别是物品Button，一般是一个Button底加Icon Sprite加数量Label的组合，提供一个统一接口，处理不同Item的样式，比如装备的彩色底框，碎片的角标，人物头像的星级等等，做到传入一个Item ID和Type，就能产生相应的Button。&lt;/p&gt;

&lt;h2 id=&#34;延时加载&#34;&gt;延时加载&lt;/h2&gt;

&lt;p&gt;有时候运气比较背，一个列表里面要加载几十个子Node，每个Node上还都有动画和各种子Node，全部添加完需要2s左右，卡顿明显，除了怂恿策划美术改图之外，延时加载也是一个解决办法——不要等列表子Node加载完再显示，先显示列表，开一个计时器，每隔0.1s~0.2s添加一个子Node，在完全加载完前禁用用户交互，虽然时间差不多，但效果要明显好于让用户卡个几秒。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>